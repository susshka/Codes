					;задание 1
(defmacro MYcond (&rest sp)        ;&rest нужен для неопределенного числа аргументов 
  (if sp                          ;проверка на пустоту
      (if (eval (caar sp))        ;проверка на возможность получить условие
	  (cons 'progn (cdar sp)) ;отделяем условие от предполагаемого результата выполнения условия
	  (cons 'mcond (cdr sp))))) ;отделяем оставшиеся условия и запускаем рекурсию с "хвостом"



				       ;задание 2

(defmacro MYwhen (test &rest args); test - условие args - выражения   
  `(if ,test (progn ,@args) nil)); обратная ковычка для создания "шаблона", упрощение синтаксиса list	; по факту получается (list 'if .....) @args вставляет значения args в шаблон

					;задание 3
(defun mnozh (w v) ;ф-ция принимает два множества
  (mapcar (lambda (e) (mapcar (lambda (a) `(,a ,e)) w)) v)) ;mapcar применяет лямбда-функцию к каждому значению множеств
					;по факту при помощи lambda (a) и обратной ковычки создается list с значениями из обоих множества w
					;за счет mapcar lambda(a) последовательно применяется ко всем значениям множества w
;а далее lambda(e) и другой mapcar записывают значения множества v

 
					;задание 4
(defun mnozh2 (w)
  (if w (append (mapcar #'(lambda (x) (list (car w) x)) (cdr w)) (mnozh2 (cdr w))) ()))

					;задание 5
(defun per (w)
  (when w (if (cdr w)                        ;когда список не пустой и если "хвост" списка так же не пустой
              (loop for a in w               ;начинается цикл, который бежит по списку
                    nconc (mapcar #'(lambda (e) (cons a e)) (per (remove a w)))) 
	      (list w))))
					;лямбда функция и mapcar поочередно соеденяют значения списка, а за счет рекурсивного вызова функции и удаления проверяемого циклом переменной из
					;списка функцией remuove, функцией nconc список "пересобирается" в новый
;так как в начале функции прописан when, после конца рекурсии функция выведет пересобранный список w





